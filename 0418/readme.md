
## 📁 1. 표준 유닉스 파일 시스템 구조

표준 유닉스 파일 시스템은 다음과 같은 4가지 주요 블록으로 구성된다:

- **부트 블록 (Boot Block)**  
  - 부팅에 필요한 정보를 포함
- **슈퍼 블록 (Super Block)**  
  - 파일 시스템 전체에 대한 정보를 저장 (블록 크기, i-node 수, 사용/미사용 블록 등)
- **i-리스트 (i-node List)**  
  - 각 파일에 대한 정보를 저장하는 i-node들의 집합
- **데이터 블록 (Data Block)**  
  - 실제 파일의 데이터가 저장되는 블록들

---

## 🧾 2. i-node와 디렉터리

- 각 **파일**은 고유한 **i-node**를 가지며, i-node는 다음 정보를 포함한다:
  - 파일 타입 (정규 파일, 디렉터리 등)
  - 접근 권한
  - 소유자 ID (UID), 그룹 ID (GID)
  - 파일 크기
  - 생성/수정/접근 시간
  - 데이터 블록의 주소 등

- **디렉터리**는 "파일 이름 + i-node 번호"로 이루어진 디렉터리 엔트리들의 리스트이다.
  - 디렉터리 자체도 하나의 파일이며, 그 파일의 i-node가 존재한다.

---

## 🔗 3. 링크 (Link)

링크는 기존 파일에 대한 **다른 이름**을 만드는 기능이다.

| 종류          | 설명                                                                 |
|---------------|----------------------------------------------------------------------|
| **하드 링크**   | 하나의 i-node를 여러 이름이 참조함. 같은 파일이지만 다른 이름으로 접근 가능. |
| **심볼릭 링크** | 새로운 파일을 만들고, 이 파일이 기존 파일의 경로를 문자열로 저장 (포인터).   |

- 하드 링크는 같은 파일 시스템 내에서만 가능하며, 원본이 삭제돼도 참조 유지.
- 심볼릭 링크는 파일 시스템을 넘을 수 있으며, 원본 삭제 시 링크가 끊어짐.

---

## 🔒 4. 파일 잠금 (File Locking)

파일 또는 파일의 일부에 대한 동시 접근 제어.

### 📌 잠금 종류

| 잠금 종류   | 설명                                           |
|-------------|------------------------------------------------|
| **읽기 잠금** | 여러 프로세스가 동시에 읽기 가능 (공유 가능)       |
| **쓰기 잠금** | 한 프로세스만 가능 (배타적 접근, 공유 불가능)     |

### 📌 관련 시스템 호출 및 함수

### fcntl()
- 고급 잠금 제어 가능 (잠금 검사, 설정, 해제)

### lockf()
- 간단한 인터페이스로 잠금 기능 수행

```c
// fcntl 예시 (쓰기 잠금)
struct flock fl;
fl.l_type = F_WRLCK;
fl.l_whence = SEEK_SET;
fl.l_start = 0;
fl.l_len = 0; // 전체 파일
fcntl(fd, F_SETLK, &fl);
```

## 📌 권고 잠금 vs 강제 잠금

| 구분 | 설명 |
|------|------|
| 권고 잠금 | 시스템은 강제하지 않으며, 개발자가 직접 체크해야 함 |
| 강제 잠금 | 커널이 잠금을 강제. 잠금된 상태에서는 접근이 차단됨 |

---

## 👨‍💻 5. 프로세스(Process) 개요

프로세스는 실행 중인 프로그램이다.

각 프로세스는 다음과 같은 정보를 가진다:
- 프로세스 ID (PID)
- 부모 프로세스 ID (PPID)
- 실제 사용자 ID / 유효 사용자 ID
- 실제 그룹 ID / 유효 그룹 ID

### 프로세스 이미지 구성
- **텍스트 영역**: 코드
- **데이터 영역**: 전역 변수, 초기화된 데이터
- **힙 영역**: 동적 메모리 (malloc 등)
- **스택 영역**: 지역 변수, 함수 호출 스택

---

## 🧬 6. 프로세스 생성 및 종료

### 📌 fork()
부모 프로세스를 복제하여 자식 프로세스를 생성

**반환값:**
- `0`: 자식 프로세스에서 반환
- `양수(PID)`: 부모 프로세스에서 반환
- `-1`: 실패

```c
pid_t pid = fork();
if (pid == 0) {
  // 자식 프로세스
} else {
  // 부모 프로세스
}
```

### 📌 exec()
현재 프로세스의 코드를 새로운 프로그램으로 대체
- exec() 호출 이후 기존 코드는 실행되지 않음

```c
execl("/bin/ls", "ls", "-l", NULL);
```

### 📌 exit()와 _exit()

| 함수 | 설명 |
|------|------|
| `exit()` | 정리 작업 수행 후 정상 종료 |
| `_exit()` | 정리 없이 즉시 종료 (fork 후 자식에서 주로 사용) |

---

## 📣 7. 시그널 (Signal)

시그널은 예기치 않은 사건을 알리는 소프트웨어 인터럽트

**예시**: SIGINT (Ctrl+C), SIGTERM, SIGKILL

```c
signal(SIGINT, handler_function);
```

---

## 🔧 8. 기본 유닉스 개발 도구

| 도구/명령어 | 설명 |
|-------------|------|
| `gedit` | GUI 기반 텍스트 편집기 (GNOME) |
| `vi / vim` | CLI 기반 텍스트 편집기, 명령/입력 모드 구분 |
| `gcc` | C 컴파일러 (a.out 기본 실행 파일 생성) |
| `make` | Makefile 기반 빌드 자동화 도구 |
| `gdb` | GNU 디버거, 실행 중인 프로그램 디버깅 가능 |

---
