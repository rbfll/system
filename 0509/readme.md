# 🖥️ 컴퓨터 시스템 구조

---

## 🧩 유닉스 커널 (Unix Kernel)

유닉스 커널은 **하드웨어를 운영·관리**하며 시스템에 다음과 같은 핵심 서비스를 제공합니다:

### 📁 1. 파일 관리 (File Management)
- 파일 생성, 삭제, 읽기, 쓰기 등 파일 시스템 전반을 관리합니다.

### 🧠 2. 프로세스 관리 (Process Management)
- 프로세스의 생성, 스케줄링, 종료 등 실행 흐름을 제어합니다.

### 💾 3. 메모리 관리 (Memory Management)
- 프로세스 간 메모리 분배 및 보호, 가상 메모리 등을 담당합니다.

### 📡 4. 통신 관리 (Communication Management)
- 프로세스 간 통신(IPC), 네트워크 통신 등을 지원합니다.

### 🔌 5. 주변장치 관리 (Device Management)
- 프린터, 디스크, 키보드 등의 입출력 장치를 제어합니다.

---

# 시스템호출
- 시스템 호출은 커널에 서비스 요청을 위한 프로그래밍 인터페이스
- 응용 프로그램은 시스템 호출을 통해서 커널에 서비스를 요청한다.

---

# 🧾 시스템 호출 요약표

| 주요 자원       | 관련 시스템 호출 예시                                                 |
|----------------|---------------------------------------------------------------------|
| 📁 파일         | `open()`, `close()`, `read()`, `write()`, `dup()`, `lseek()`       |
| 🔄 프로세스     | `fork()`, `exec()`, `exit()`, `wait()`, `getpid()`, `getppid()`     |
| 💾 메모리       | `malloc()`, `calloc()`, `free()`                                     |
| 🚨 시그널       | `signal()`, `alarm()`, `kill()`, `sleep()`                           |
| 🔗 프로세스 간 통신 | `pipe()`, `socket()`                                               |

---

## 🧠 핵심 개념 요약

- **시스템 호출(System Call)**  
  커널 서비스를 요청하기 위한 프로그래밍 인터페이스입니다.  
  응용 프로그램은 시스템 호출을 통해 커널의 기능을 사용할 수 있습니다.

- **파일 디스크립터(File Descriptor)**  
  열린 파일을 나타내는 정수형 식별자입니다.  
  시스템은 파일을 열 때마다 파일 디스크립터를 반환합니다.

- **`open()`**  
  파일을 열고, 해당 파일의 **파일 디스크립터**를 반환합니다.

- **`read()` / `write()`**  
  - `read()`는 지정된 파일에서 원하는 만큼의 데이터를 읽습니다.  
  - `write()`는 지정된 파일에 원하는 만큼의 데이터를 씁니다.

- **파일 위치 포인터(File Offset)**  
  파일 내에서 데이터를 읽거나 쓸 **현재 위치**를 나타냅니다.

- **`lseek()`**  
  지정된 파일의 **현재 위치 포인터**를 원하는 위치로 이동시킵니다.

---

# 💻 부팅 시 ROM에서 하는 작업

컴퓨터나 전자기기가 부팅될 때, **ROM(Read-Only Memory)**은 시스템을 준비시키는 핵심적인 역할을 합니다. 
---

### ✅ 1. 전원 공급 후 초기화 (POST: Power-On Self Test)
- CPU, 메모리, 키보드, 디스크 등의 하드웨어 장치 상태를 점검합니다.
- 문제가 있을 경우 비프음 또는 오류 메시지로 알려줍니다.

### ✅ 2. 부트로더(Bootloader) 실행
- 운영체제를 불러오기 위한 부트로더를 실행합니다.
- 이 부트로더는 ROM에 저장된 BIOS 또는 UEFI에 포함되어 있습니다.

### ✅ 3. BIOS 또는 UEFI 구동
- 하드웨어와 소프트웨어 간 기본 통신을 설정합니다.
- 운영체제가 로딩될 때까지 필요한 장치들을 사용할 수 있도록 초기화합니다.

### 🧠 요약
ROM은 운영체제가 실행되기 전에 시스템의 **하드웨어 점검, 부트로더 실행, 장치 초기화** 등을 수행하며, 전체 시스템이 안정적으로 동작할 수 있도록 기반을 마련합니다.

---

# 📂 파일 시스템 구조

---

## 🧱 1. 파일 시스템의 주요 구성 요소

| 구성 요소        | 설명 |
|------------------|------|
| **부트 블록 (Boot Block)** | - 파일 시스템의 시작 부분에 위치<br>- 보통 디스크의 첫 번째 섹터 차지<br>- 부트스트랩 코드 저장 |
| **슈퍼 블록 (Super Block)** | - 전체 파일 시스템에 대한 정보 저장<br>- 총 블록 수, 사용 가능한 i-노드 수, 사용 가능한 블록 비트맵, 블록 크기 등 |
| **i-리스트 (i-list)** | - 모든 i-노드들의 리스트<br>- 한 블록당 약 40개의 i-노드 포함 |
| **데이터 블록 (Data Block)** | - 실제 파일의 내용(데이터)을 저장하는 블록들 |

---

## 📄 2. i-노드 (i-Node)

- 하나의 파일은 하나의 **i-노드**를 가집니다.
- i-노드는 해당 파일에 대한 **모든 메타데이터**를 저장합니다.

### i-노드가 포함하는 정보:

- 📁 **파일 타입**: 일반 파일, 디렉터리, 블록 장치, 문자 장치 등  
- 📏 **파일 크기**  
- 🔐 **사용 권한 (Permission)**  
- 👤 **파일 소유자 및 그룹**  
- 🕒 **접근/수정/변경 시간**  
- 📍 **데이터 블록에 대한 포인터 (주소 정보)**

---

# 파일 디스크립터 배열 (FdArray) 📂

## 개요 🌟
파일 디스크립터 배열(FdArray)은 프로세스가 열린 파일들을 관리하는 구조로, 각 프로세스마다 하나씩 갖고 있습니다. 이 배열은 프로세스가 열린 파일에 대한 정보를 저장하고, 파일 디스크립터를 통해 파일에 접근할 수 있도록 합니다.

## 주요 개념 🧠

### 1. 프로세스당 하나씩 갖는다 👥
- 각 프로세스는 자신만의 파일 디스크립터 배열을 가집니다.
- 이를 통해 각 프로세스는 자신이 열린 파일을 독립적으로 관리하고 추적할 수 있습니다.

### 2. 파일 디스크립터 배열 📋
- 파일 디스크립터 배열은 열린 파일 테이블의 특정 엔트리를 가리킵니다.
- 열린 파일 테이블은 운영체제가 관리하며, 파일의 실제 위치나 상태에 대한 정보를 포함합니다.

### 3. 파일 디스크립터 🔢
- 파일 디스크립터는 파일 디스크립터 배열의 인덱스 값입니다.
- 이는 열린 파일을 나타내는 번호로, 해당 번호를 통해 파일에 접근하고 읽기/쓰기 작업을 수행합니다.

## 예시 💻
프로세스 A가 파일을 열면, 운영체제는 열린 파일 테이블에 해당 파일을 등록합니다. 프로세스 A의 파일 디스크립터 배열에는 그 파일을 가리키는 인덱스(파일 디스크립터)가 저장됩니다. 이후, 프로세스 A는 이 파일 디스크립터를 통해 파일에 접근하게 됩니다.

## 결론 🎯
파일 디스크립터 배열은 여러 프로세스가 동시에 파일을 열고 독립적으로 파일에 접근할 수 있도록 보장하는 중요한 구조입니다.

---

# 열린 파일 테이블 (Open File Table) 📂

## 개요 🌟
열린 파일 테이블(Open File Table)은 커널이 관리하는 자료구조로, 시스템에서 열린 모든 파일에 대한 정보를 저장합니다. 각 열린 파일은 파일 테이블의 항목을 통해 관리됩니다.

## 주요 개념 🧠

### 1. 파일 테이블 (File Table) 📋
- **커널 자료구조**: 파일 테이블은 운영체제의 커널에서 관리됩니다.
- **열려진 모든 파일 목록**: 시스템에서 열린 모든 파일에 대한 목록을 유지하고 있습니다.
- **열려진 파일**: 열린 파일은 파일 테이블의 항목에 의해 추적됩니다.

### 2. 파일 테이블 항목 (File Table Entry) 🔑
파일 테이블의 각 항목은 열린 파일에 대한 중요한 정보를 포함합니다:
- **파일 상태 플래그 (File Status Flags)**: 파일의 동작 상태를 나타내는 플래그입니다.
  - 예: `read`, `write`, `append`, `sync`, `nonblocking` 등
- **파일의 현재 위치 (Current File Offset)**: 파일에서 현재 읽거나 쓸 위치를 추적합니다.
- **i-node에 대한 포인터 (Pointer to i-node)**: 파일의 메타데이터를 포함한 i-node 구조체에 대한 포인터입니다. 이를 통해 파일의 실제 저장 위치와 기타 정보를 찾을 수 있습니다.

## 예시 💻
시스템에서 사용자가 파일을 열면, 운영체제는 열린 파일 테이블에 해당 파일의 항목을 생성합니다. 이 항목에는 파일의 상태, 현재 파일 위치, i-node 정보 등이 저장되어, 이후 파일을 읽거나 쓸 때 필요한 정보를 제공합니다.

## 결론 🎯
열린 파일 테이블은 파일을 효율적으로 관리하고, 여러 프로세스가 파일에 동시에 접근할 수 있도록 돕는 중요한 커널 자료구조입니다. 파일의 상태, 위치, 메타데이터 등을 추적하며 시스템의 파일 작업을 원활하게 합니다.

---

# 동적 i-노드 테이블 (Active i-node Table) 💾

## 개요 🌟
동적 i-노드 테이블은 커널에서 관리하는 자료구조로, 열린 파일들의 i-노드를 저장하는 테이블입니다. i-노드는 파일의 메타데이터를 담고 있으며, 하드디스크에 저장된 파일에 대한 중요한 정보를 제공합니다.

## 주요 개념 🧠

### 1. 동적 i-노드 테이블 (Dynamic i-node Table) 📋
- **커널 내의 자료구조**: 동적 i-노드 테이블은 운영체제의 커널에서 관리됩니다.
- **열린 파일들의 i-노드 저장**: 이 테이블은 현재 열린 파일들의 i-노드를 저장하며, 각 열린 파일에 대한 메타데이터를 관리합니다.

### 2. i-노드 (i-node) 🔑
- **하드디스크에 저장되어 있는 파일에 대한 자료구조**: i-노드는 하드디스크에 있는 파일의 메타데이터를 담고 있습니다.
- **파일당 하나의 i-노드**: 각 파일에는 고유한 i-노드가 하나씩 존재합니다.
- **파일에 대한 정보 저장**:
  - **소유자**: 파일을 소유한 사용자 정보.
  - **파일 크기**: 파일의 크기.
  - **파일이 위치한 장치**: 파일이 저장된 물리적 장치에 대한 정보.
  - **파일 내용 디스크 블록에 대한 포인터**: 파일 데이터가 저장된 디스크 블록에 대한 포인터입니다.

### 3. i-노드 테이블 vs. i-노드 🔄
- **i-노드 테이블**: 여러 i-노드가 모여 있는 테이블입니다. 이는 운영체제가 파일 시스템에서 관리하는 i-노드들의 집합으로, 열린 파일에 해당하는 i-노드를 포함하고 있습니다.
- **i-노드**: 개별 파일에 대한 메타데이터를 저장하는 자료구조로, 각 파일마다 하나씩 존재합니다.

## 예시 💻
파일을 열면 운영체제는 동적 i-노드 테이블에 해당 파일의 i-노드를 저장합니다. 이 i-노드에는 파일의 소유자, 크기, 위치 정보, 데이터 블록에 대한 포인터 등이 포함되어, 파일의 실제 데이터를 찾아 사용할 수 있도록 돕습니다.

## 결론 🎯
동적 i-노드 테이블은 열린 파일들의 i-노드를 관리하며, 파일 시스템에서 파일의 메타데이터를 추적하는 중요한 역할을 합니다. 이를 통해 운영체제는 파일을 효율적으로 관리하고, 필요한 정보를 빠르게 찾아낼 수 있습니다.


