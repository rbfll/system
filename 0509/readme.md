# 🖥️ 컴퓨터 시스템 구조

---

## 🧩 유닉스 커널 (Unix Kernel)

유닉스 커널은 **하드웨어를 운영·관리**하며 시스템에 다음과 같은 핵심 서비스를 제공합니다:

### 📁 1. 파일 관리 (File Management)
- 파일 생성, 삭제, 읽기, 쓰기 등 파일 시스템 전반을 관리합니다.

### 🧠 2. 프로세스 관리 (Process Management)
- 프로세스의 생성, 스케줄링, 종료 등 실행 흐름을 제어합니다.

### 💾 3. 메모리 관리 (Memory Management)
- 프로세스 간 메모리 분배 및 보호, 가상 메모리 등을 담당합니다.

### 📡 4. 통신 관리 (Communication Management)
- 프로세스 간 통신(IPC), 네트워크 통신 등을 지원합니다.

### 🔌 5. 주변장치 관리 (Device Management)
- 프린터, 디스크, 키보드 등의 입출력 장치를 제어합니다.

---

# 시스템호출
- 시스템 호출은 커널에 서비스 요청을 위한 프로그래밍 인터페이스
- 응용 프로그램은 시스템 호출을 통해서 커널에 서비스를 요청한다.

---

# 🧾 시스템 호출 요약표

| 주요 자원       | 관련 시스템 호출 예시                                                 |
|----------------|---------------------------------------------------------------------|
| 📁 파일         | `open()`, `close()`, `read()`, `write()`, `dup()`, `lseek()`       |
| 🔄 프로세스     | `fork()`, `exec()`, `exit()`, `wait()`, `getpid()`, `getppid()`     |
| 💾 메모리       | `malloc()`, `calloc()`, `free()`                                     |
| 🚨 시그널       | `signal()`, `alarm()`, `kill()`, `sleep()`                           |
| 🔗 프로세스 간 통신 | `pipe()`, `socket()`                                               |

---

## 🧠 핵심 개념 요약

- **시스템 호출(System Call)**  
  커널 서비스를 요청하기 위한 프로그래밍 인터페이스입니다.  
  응용 프로그램은 시스템 호출을 통해 커널의 기능을 사용할 수 있습니다.

- **파일 디스크립터(File Descriptor)**  
  열린 파일을 나타내는 정수형 식별자입니다.  
  시스템은 파일을 열 때마다 파일 디스크립터를 반환합니다.

- **`open()`**  
  파일을 열고, 해당 파일의 **파일 디스크립터**를 반환합니다.

- **`read()` / `write()`**  
  - `read()`는 지정된 파일에서 원하는 만큼의 데이터를 읽습니다.  
  - `write()`는 지정된 파일에 원하는 만큼의 데이터를 씁니다.

- **파일 위치 포인터(File Offset)**  
  파일 내에서 데이터를 읽거나 쓸 **현재 위치**를 나타냅니다.

- **`lseek()`**  
  지정된 파일의 **현재 위치 포인터**를 원하는 위치로 이동시킵니다.

---

# 💻 부팅 시 ROM에서 하는 작업

컴퓨터나 전자기기가 부팅될 때, **ROM(Read-Only Memory)**은 시스템을 준비시키는 핵심적인 역할을 합니다. 
---

### ✅ 1. 전원 공급 후 초기화 (POST: Power-On Self Test)
- CPU, 메모리, 키보드, 디스크 등의 하드웨어 장치 상태를 점검합니다.
- 문제가 있을 경우 비프음 또는 오류 메시지로 알려줍니다.

### ✅ 2. 부트로더(Bootloader) 실행
- 운영체제를 불러오기 위한 부트로더를 실행합니다.
- 이 부트로더는 ROM에 저장된 BIOS 또는 UEFI에 포함되어 있습니다.

### ✅ 3. BIOS 또는 UEFI 구동
- 하드웨어와 소프트웨어 간 기본 통신을 설정합니다.
- 운영체제가 로딩될 때까지 필요한 장치들을 사용할 수 있도록 초기화합니다.

### 🧠 요약
ROM은 운영체제가 실행되기 전에 시스템의 **하드웨어 점검, 부트로더 실행, 장치 초기화** 등을 수행하며, 전체 시스템이 안정적으로 동작할 수 있도록 기반을 마련합니다.

---

# 📂 파일 시스템 구조

---

## 🧱 1. 파일 시스템의 주요 구성 요소

| 구성 요소        | 설명 |
|------------------|------|
| **부트 블록 (Boot Block)** | - 파일 시스템의 시작 부분에 위치<br>- 보통 디스크의 첫 번째 섹터 차지<br>- 부트스트랩 코드 저장 |
| **슈퍼 블록 (Super Block)** | - 전체 파일 시스템에 대한 정보 저장<br>- 총 블록 수, 사용 가능한 i-노드 수, 사용 가능한 블록 비트맵, 블록 크기 등 |
| **i-리스트 (i-list)** | - 모든 i-노드들의 리스트<br>- 한 블록당 약 40개의 i-노드 포함 |
| **데이터 블록 (Data Block)** | - 실제 파일의 내용(데이터)을 저장하는 블록들 |

---

## 📄 2. i-노드 (i-Node)

- 하나의 파일은 하나의 **i-노드**를 가집니다.
- i-노드는 해당 파일에 대한 **모든 메타데이터**를 저장합니다.

### i-노드가 포함하는 정보:

- 📁 **파일 타입**: 일반 파일, 디렉터리, 블록 장치, 문자 장치 등  
- 📏 **파일 크기**  
- 🔐 **사용 권한 (Permission)**  
- 👤 **파일 소유자 및 그룹**  
- 🕒 **접근/수정/변경 시간**  
- 📍 **데이터 블록에 대한 포인터 (주소 정보)**

---

# 파일 디스크립터 배열 (FdArray) 📂

## 개요 🌟
파일 디스크립터 배열(FdArray)은 프로세스가 열린 파일들을 관리하는 구조로, 각 프로세스마다 하나씩 갖고 있습니다. 이 배열은 프로세스가 열린 파일에 대한 정보를 저장하고, 파일 디스크립터를 통해 파일에 접근할 수 있도록 합니다.

## 주요 개념 🧠

### 1. 프로세스당 하나씩 갖는다 👥
- 각 프로세스는 자신만의 파일 디스크립터 배열을 가집니다.
- 이를 통해 각 프로세스는 자신이 열린 파일을 독립적으로 관리하고 추적할 수 있습니다.

### 2. 파일 디스크립터 배열 📋
- 파일 디스크립터 배열은 열린 파일 테이블의 특정 엔트리를 가리킵니다.
- 열린 파일 테이블은 운영체제가 관리하며, 파일의 실제 위치나 상태에 대한 정보를 포함합니다.

### 3. 파일 디스크립터 🔢
- 파일 디스크립터는 파일 디스크립터 배열의 인덱스 값입니다.
- 이는 열린 파일을 나타내는 번호로, 해당 번호를 통해 파일에 접근하고 읽기/쓰기 작업을 수행합니다.

## 예시 💻
프로세스 A가 파일을 열면, 운영체제는 열린 파일 테이블에 해당 파일을 등록합니다. 프로세스 A의 파일 디스크립터 배열에는 그 파일을 가리키는 인덱스(파일 디스크립터)가 저장됩니다. 이후, 프로세스 A는 이 파일 디스크립터를 통해 파일에 접근하게 됩니다.

## 결론 🎯
파일 디스크립터 배열은 여러 프로세스가 동시에 파일을 열고 독립적으로 파일에 접근할 수 있도록 보장하는 중요한 구조입니다.

---

# 열린 파일 테이블 (Open File Table) 📂

## 개요 🌟
열린 파일 테이블(Open File Table)은 커널이 관리하는 자료구조로, 시스템에서 열린 모든 파일에 대한 정보를 저장합니다. 각 열린 파일은 파일 테이블의 항목을 통해 관리됩니다.

## 주요 개념 🧠

### 1. 파일 테이블 (File Table) 📋
- **커널 자료구조**: 파일 테이블은 운영체제의 커널에서 관리됩니다.
- **열려진 모든 파일 목록**: 시스템에서 열린 모든 파일에 대한 목록을 유지하고 있습니다.
- **열려진 파일**: 열린 파일은 파일 테이블의 항목에 의해 추적됩니다.

### 2. 파일 테이블 항목 (File Table Entry) 🔑
파일 테이블의 각 항목은 열린 파일에 대한 중요한 정보를 포함합니다:
- **파일 상태 플래그 (File Status Flags)**: 파일의 동작 상태를 나타내는 플래그입니다.
  - 예: `read`, `write`, `append`, `sync`, `nonblocking` 등
- **파일의 현재 위치 (Current File Offset)**: 파일에서 현재 읽거나 쓸 위치를 추적합니다.
- **i-node에 대한 포인터 (Pointer to i-node)**: 파일의 메타데이터를 포함한 i-node 구조체에 대한 포인터입니다. 이를 통해 파일의 실제 저장 위치와 기타 정보를 찾을 수 있습니다.

## 예시 💻
시스템에서 사용자가 파일을 열면, 운영체제는 열린 파일 테이블에 해당 파일의 항목을 생성합니다. 이 항목에는 파일의 상태, 현재 파일 위치, i-node 정보 등이 저장되어, 이후 파일을 읽거나 쓸 때 필요한 정보를 제공합니다.

## 결론 🎯
열린 파일 테이블은 파일을 효율적으로 관리하고, 여러 프로세스가 파일에 동시에 접근할 수 있도록 돕는 중요한 커널 자료구조입니다. 파일의 상태, 위치, 메타데이터 등을 추적하며 시스템의 파일 작업을 원활하게 합니다.

---

# 동적 i-노드 테이블 (Active i-node Table) 💾

## 개요 🌟
동적 i-노드 테이블은 커널에서 관리하는 자료구조로, 열린 파일들의 i-노드를 저장하는 테이블입니다. i-노드는 파일의 메타데이터를 담고 있으며, 하드디스크에 저장된 파일에 대한 중요한 정보를 제공합니다.

## 주요 개념 🧠

### 1. 동적 i-노드 테이블 (Dynamic i-node Table) 📋
- **커널 내의 자료구조**: 동적 i-노드 테이블은 운영체제의 커널에서 관리됩니다.
- **열린 파일들의 i-노드 저장**: 이 테이블은 현재 열린 파일들의 i-노드를 저장하며, 각 열린 파일에 대한 메타데이터를 관리합니다.

### 2. i-노드 (i-node) 🔑
- **하드디스크에 저장되어 있는 파일에 대한 자료구조**: i-노드는 하드디스크에 있는 파일의 메타데이터를 담고 있습니다.
- **파일당 하나의 i-노드**: 각 파일에는 고유한 i-노드가 하나씩 존재합니다.
- **파일에 대한 정보 저장**:
  - **소유자**: 파일을 소유한 사용자 정보.
  - **파일 크기**: 파일의 크기.
  - **파일이 위치한 장치**: 파일이 저장된 물리적 장치에 대한 정보.
  - **파일 내용 디스크 블록에 대한 포인터**: 파일 데이터가 저장된 디스크 블록에 대한 포인터입니다.

### 3. i-노드 테이블 vs. i-노드 🔄
- **i-노드 테이블**: 여러 i-노드가 모여 있는 테이블입니다. 이는 운영체제가 파일 시스템에서 관리하는 i-노드들의 집합으로, 열린 파일에 해당하는 i-노드를 포함하고 있습니다.
- **i-노드**: 개별 파일에 대한 메타데이터를 저장하는 자료구조로, 각 파일마다 하나씩 존재합니다.

## 예시 💻
파일을 열면 운영체제는 동적 i-노드 테이블에 해당 파일의 i-노드를 저장합니다. 이 i-노드에는 파일의 소유자, 크기, 위치 정보, 데이터 블록에 대한 포인터 등이 포함되어, 파일의 실제 데이터를 찾아 사용할 수 있도록 돕습니다.

## 결론 🎯
동적 i-노드 테이블은 열린 파일들의 i-노드를 관리하며, 파일 시스템에서 파일의 메타데이터를 추적하는 중요한 역할을 합니다. 이를 통해 운영체제는 파일을 효율적으로 관리하고, 필요한 정보를 빠르게 찾아낼 수 있습니다.

---

# 파일 타입 (File Types) 📂

## 파일 타입 설명표

| 파일 타입          | 설명                                                                 | 예시                              |
|------------------|----------------------------------------------------------------------|----------------------------------|
| **일반 파일** (Regular File) | 데이터가 포함된 텍스트 파일 또는 이진 파일                          | 텍스트 문서, 이미지 파일, 실행 파일 |
| **디렉터리 파일** (Directory File) | 파일 이름들과 해당 파일에 대한 정보를 포함하는 파일                 | `/home/user/` (디렉터리)           |
| **문자 장치 파일** (Character Device File) | 문자 단위로 데이터를 전송하는 장치를 나타내는 파일                   | `/dev/tty`, `/dev/keyboard` (터미널 장치) |
| **블록 장치 파일** (Block Device File) | 블록 단위로 데이터를 전송하는 장치를 나타내는 파일                   | `/dev/sda`, `/dev/sdb` (하드 드라이브, USB) |
| **FIFO 파일** (FIFO File) | 프로세스 간 통신에 사용되는 이름 있는 파이프                           | `/tmp/my_fifo`                   |
| **소켓 파일** (Socket File) | 네트워크를 통한 프로세스 간 통신에 사용되는 파일                      | Unix 도메인 소켓, 네트워크 소켓   |
| **심볼릭 링크** (Symbolic Link) | 다른 파일을 가리키는 포인터 역할을 하는 파일                          | `/home/user/file_link`           |

---

# 파일 타입 검사 함수 (File Type Checking Macros) 🔍

## 파일 타입 및 검사 함수 🧠

| 파일 타입               | 검사 함수          | 설명                                                   |
|----------------------|------------------|------------------------------------------------------|
| **일반 파일** (Regular File) | `S_ISREG()`       | 파일이 일반 파일인지 검사                             |
| **디렉터리 파일** (Directory File) | `S_ISDIR()`       | 파일이 디렉터리인지 검사                              |
| **문자 장치 파일** (Character Device File) | `S_ISCHR()`       | 파일이 문자 장치 파일인지 검사                        |
| **블록 장치 파일** (Block Device File) | `S_ISBLK()`       | 파일이 블록 장치 파일인지 검사                        |
| **FIFO 파일** (FIFO File)  | `S_ISFIFO()`      | 파일이 FIFO(이름 있는 파이프) 파일인지 검사            |
| **소켓 파일** (Socket File) | `S_ISSOCK()`      | 파일이 소켓 파일인지 검사                              |
| **심볼릭 링크** (Symbolic Link) | `S_ISLNK()`       | 파일이 심볼릭 링크인지 검사                            |

---

# 파일 사용 권한 (File Permissions) 🛠️

## 개요 🌟
파일 사용 권한은 각 파일에 대해 누가 어떤 작업을 할 수 있는지를 정의하는 중요한 시스템 기능입니다. 파일 시스템에서 각 파일은 **소유자(owner)**, **그룹(group)**, **기타(others)**로 구분하여 권한을 관리합니다.

## 파일 사용 권한 구성 🧠

파일 권한은 세 가지 주요 항목으로 나뉩니다:
- **읽기 (r)**: 파일의 내용을 읽을 수 있는 권한.
- **쓰기 (w)**: 파일의 내용을 수정할 수 있는 권한.
- **실행 (x)**: 파일을 실행할 수 있는 권한.

각 파일은 **소유자 (owner)**, **그룹 (group)**, **기타 사용자 (others)**에 대한 권한을 따로 설정할 수 있습니다.

## 권한 설정 방식 🔑
파일 권한은 다음과 같이 구분하여 설정됩니다:
1. **소유자 (Owner)**: 파일을 생성한 사용자에게 부여되는 권한.
2. **그룹 (Group)**: 파일 소유자와 같은 그룹에 속한 사용자에게 부여되는 권한.
3. **기타 사용자 (Others)**: 소유자나 그룹에 속하지 않는 모든 사용자에게 부여되는 권한.

---

# 사용 권한 (File Permissions) 🛠️

## 개요 🌟
파일을 열거나 디렉토리에서 작업을 수행할 때는 적절한 권한이 필요합니다. 각 권한에 따라 어떤 작업을 수행할 수 있는지 결정됩니다.

## 파일 사용 권한과 열기 옵션 🔑

### 1. **read 권한 (읽기 권한)** 📖
- **필요한 권한**: 읽기 권한 (`r`)
- **사용 가능한 열기 옵션**:
  - `O_RDONLY`: 파일을 읽기 전용으로 열 수 있습니다.
  - `O_RDWR`: 파일을 읽기 및 쓰기 모드로 열 수 있습니다.
- **설명**: 파일에 대한 읽기 권한이 있어야 해당 파일을 열고 내용을 읽을 수 있습니다.

### 2. **write 권한 (쓰기 권한)** 📝
- **필요한 권한**: 쓰기 권한 (`w`)
- **사용 가능한 열기 옵션**:
  - `O_WRONLY`: 파일을 쓰기 전용으로 열 수 있습니다.
  - `O_RDWR`: 파일을 읽고 쓸 수 있는 모드로 열 수 있습니다.
  - `O_TRUNC`: 파일을 열 때 기존 내용을 잘라내고 새로 쓸 수 있게 합니다.
- **설명**: 파일에 대한 쓰기 권한이 있어야 해당 파일을 열고 데이터를 수정하거나 추가할 수 있습니다.

## 디렉토리에서의 사용 권한 🗂️

### 3. **디렉토리에 대한 write 및 execute 권한** 🏗️
- **필요한 권한**: 쓰기 권한 (`w`) + 실행 권한 (`x`)
- **파일 생성 및 삭제**:
  - 디렉토리에 **쓰기** 및 **실행** 권한이 있어야 그 디렉토리에서 파일을 생성하거나 삭제할 수 있습니다.
  - **파일 삭제**: 디렉토리에서 파일을 삭제할 때 해당 파일에 대해 읽기(`r`)나 쓰기(`w`) 권한이 없어도 삭제가 가능합니다. 다만, 디렉토리에서 삭제할 권한이 있어야 합니다.
  
## 결론 🎯
파일과 디렉토리의 권한 설정은 시스템에서 파일과 디렉토리를 어떻게 다룰지 결정하는 중요한 요소입니다. 올바른 권한을 설정하여, 파일을 안전하고 효율적으로 관리할 수 있습니다.

---

## 🎯실습

![image](https://github.com/user-attachments/assets/ea3d5e82-262f-427a-b5d4-3ac9080a4776)

